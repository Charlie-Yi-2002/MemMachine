---
title: "Memory Types"
description: "How MemMachine organizes Memory"
icon: "memory"
---
## Memory Types

MemMachine works as an intelligent memory layer on top of a user's Agentic LLM experience.  It gathers input via Python APIs in a Memory Instance, then determines if that input is profile, short-term and/or long-term:  
 - **Profile memory** consists of information specific to the user and their experience.  
 - **Short-term memory** consists of episodic memory and summaries of the episodic memory.  A raw episode consists of 1 message. 
 - **Long-term memory** consists of a batch of episodes that is generated from the short-term memories.  The Episode batch is then ranked using a Reranker and deduplicated for the most frequent hits.  

## How does MemMachine sort into it's Memory Types?

MemMachine utilizes an embedder to break apart user/agent language into distinct computer understandable derivatives.  These derivatives are then passed through a re-ranker which compares the results to those found in the long-term memory buckets, then returns the top, sorted matches.

After the re-ranker completes it's activity, memory is stored into an associated database.  



### Profile Memory

Profile memory specifically focuses on information and data specific to a user and their experience.  The data is stored in a PostgreSQL database.


**Memory Storage Process**
     1. Raw user messages go into session_history
     2. An LLM analyzes conversations to extract meaningful knowledge
     3. Structured knowledge gets stored in memvergeprofile with vector embeddings
     4. The citations table links each piece of knowledge back to its source conversations

**Memory Retrieval Process**
     1. **Query**: User asks a question or system needs context
     2. **Semantic Search**: System uses vector embeddings to find relevant knowledge
     3. **Retrieval**: Returns matching profile entries with their associated conversation sources
     4. **Context**: Citations provide traceability back to original conversations



There are 3 primary tables that are used within the database to manage Profile Memory:

#### Profile Table 

The Profile Table stores semantic knowledge about users in a structured format.

Here's an example Profile table:
```bash
       Column       |           Type           | Collation | Nullable |                   Default                   
--------------------+--------------------------+-----------+----------+---------------------------------------------
 id                 | integer                  |           | not null | nextval('memvergeprofile_id_seq'::regclass)
 user_id            | text                     |           | not null | 
 tag                | text                     |           | not null | 'Miscellaneous'::text
 feature            | text                     |           | not null | 
 value              | text                     |           | not null | 
 deleted            | integer                  |           | not null | 0
 create_at          | timestamp with time zone |           | not null | CURRENT_TIMESTAMP
 update_at          | timestamp with time zone |           | not null | CURRENT_TIMESTAMP
 delete_at          | text                     |           |          | 
 metadata_timestamp | text                     |           |          | 
 group_id           | text                     |           |          | 
 embedding          | vector(1536)             |           | not null | 
Indexes:
    "memvergeprofile_pkey" PRIMARY KEY, btree (id)
    "unique_utfv" UNIQUE CONSTRAINT, btree (user_id, tag, feature, value)
Referenced by:
    TABLE "citations" CONSTRAINT "citations_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES memvergeprofile(id) ON DELETE CASCADE
```

This table consists of the following fields:

| Field       | Explanation                                                  |
| ----------- | ------------------------------------------------------------ |
| user      | Unique integer identifier for each profile entry |
| user_id   | This integer is a unique ID specific to the user that is interacting with the agent.  The ID organizes all information about the user, and only this user. |
| tag       | A high-level categorization (e.g., "Preferences", "Skills", "Background"). |
| feature   | An executive summary of the information (e.g., "likes_pizza", "programming_language") |
| value     | Detailed content of the knowledge (e.g., "Margherita with extra cheese", "Python, JavaScript, Go") |
| deleted   | Soft delete flag (0 = active, 1 = deleted) |
| create_at | This is a timestamp for when the listing in the table was created. |
| update_at | This is a timestamp for when the listing in the table was last updated. |
| delete_at | This is a text field used for noting when the listing in the table was deleted. |
| metadata_timestamp | This shows when the knowledge was last updated |
| group_id  | This field allows for an optional grouping of associated memories |
| embedding | MemMachine creates a detailed 1536-trait numerical fingerprint for each memory, enabling smart, meaning-based searches to find the most relevant context. |

<Note> The `unique_utfv` constraint ensures no duplicate knowledge entries for the same user, tag, feature, and value combination. </Note>

#### History Table

The History Table stores information pertaining to the User's history.

Below is an example of a History Table:
```bash
Column   |  Type   | Collation | Nullable |                   Default                   
------------+---------+-----------+----------+---------------------------------------------
 id         | integer |           | not null | nextval('session_history_id_seq'::regclass)
 group_id   | text    |           |          | 
 user_id    | text    |           | not null | 
 session_id | text    |           |          | 
 content    | text    |           | not null | 
 timestamp  | text    |           | not null | 
Indexes:
    "session_history_pkey" PRIMARY KEY, btree (id)
Referenced by:
    TABLE "citations" CONSTRAINT "citations_content_id_fkey" FOREIGN KEY (content_id) REFERENCES session_history(id)
```
This table consists of the following fields:

| Field       | Explanation                                                  |
| ----------- | ------------------------------------------------------------ |
| id          | Unique identifier for each conversation entry. |
| user_id     | This integer is a unique ID specific to the user that is interacting with the agent.  The ID organizes all information about the user, and only this user. |
| group_id    | Optional grouping for conversation sessions |
| session_id  | Groups related conversations together |
| content     | The actual conversation text |
| timestamp   | When the conversation occured |

#### Citations Table

This junction table creates audit trails between knowledge and its sources.

Below is an example of a Citations Table:
```bash
   Column   |  Type   | Collation | Nullable | Default 
------------+---------+-----------+----------+---------
 profile_id | integer |           | not null | 
 content_id | integer |           | not null | 
Indexes:
    "citations_pkey" PRIMARY KEY, btree (profile_id, content_id)
Foreign-key constraints:
    "citations_content_id_fkey" FOREIGN KEY (content_id) REFERENCES session_history(id)
    "citations_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES memvergeprofile(id) ON DELETE CASCADE
```
This table consists of the following fields:
| Field       | Explanation                                                  |
| ----------- | ------------------------------------------------------------ |
| profile_id  | References the knowledge entry in `memvergeprofile` |
| content_id  | References the conversation source in `session_history` |
